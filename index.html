import React, { useState, useEffect } from 'react';
import { AlertCircle, Check, Clock, Lightbulb, RefreshCcw, ExternalLink } from 'lucide-react';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';

const EMPTY = 0;
const CHAIR = 1;
const ECO = 2;

const SUSTAINABILITY_FACTS = [
  "Did you know? KIAN's commitment to sustainability has led to a 30% reduction in our carbon footprint over the last 5 years.",
  "KIAN uses recycled materials in over 60% of our furniture products.",
  "Our sustainable practices have helped save over 1000 trees annually through our eco-friendly manufacturing processes."
];

const KianPuzzle = () => {
  // Game state
  const [grid, setGrid] = useState([
    [EMPTY, EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, EMPTY]
  ]);
  const [isComplete, setIsComplete] = useState(false);
  const [errors, setErrors] = useState([]);
  const [hintIndex, setHintIndex] = useState(-1);
  const [time, setTime] = useState(0);
  const [isActive, setIsActive] = useState(false);
  const [highlightedCells, setHighlightedCells] = useState([]);
  const [incompleteMessage, setIncompleteMessage] = useState(null);

  // Puzzle configuration
  const horizontalConstraints = [
    [null, '=', null, null],
    [null, 'X', null, null],
    [null, null, '=', null],
    [null, null, null, null]
  ];

  const verticalConstraints = [
    [null, null, 'X', null],
    [null, '=', null, null],
    [null, null, null, null],
    [null, null, null, null]
  ];

  useEffect(() => {
    let interval = null;
    if (isActive && !isComplete) {
      interval = setInterval(() => {
        setTime(time => time + 1);
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [isActive, isComplete]);

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const generateHint = () => {
    // Check for constraint violations
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 3; j++) {
        // Check horizontal constraints
        if (horizontalConstraints[i][j]) {
          const cell1 = grid[i][j];
          const cell2 = grid[i][j+1];
          if (cell1 !== EMPTY && cell2 !== EMPTY) {
            if (horizontalConstraints[i][j] === '=' && cell1 !== cell2) {
              return {
                tip: `Check row ${i + 1}. The cells connected by = must contain the same symbol.`,
                highlight: [[i, j], [i, j+1]],
                solution: "These cells must match"
              };
            }
            if (horizontalConstraints[i][j] === 'X' && cell1 === cell2) {
              return {
                tip: `Check row ${i + 1}. The cells connected by × must contain different symbols.`,
                highlight: [[i, j], [i, j+1]],
                solution: "These cells must be different"
              };
            }
          }
        }
      }
    }

    // Check for three in a row violations
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 2; j++) {
        // Horizontal check
        if (grid[i][j] !== EMPTY && 
            grid[i][j] === grid[i][j+1] && 
            grid[i][j] === grid[i][j+2]) {
          return {
            tip: "Remember, no more than two identical symbols can be adjacent.",
            highlight: [[i, j], [i, j+1], [i, j+2]],
            solution: `One of these cells must be changed to avoid three ${grid[i][j] === CHAIR ? 'chairs' : 'sustainability symbols'} in a row`
          };
        }
        // Vertical check
        if (grid[j][i] !== EMPTY && 
            grid[j][i] === grid[j+1][i] && 
            grid[j][i] === grid[j+2][i]) {
          return {
            tip: "Check this column. No more than two identical symbols can be adjacent.",
            highlight: [[j, i], [j+1, i], [j+2, i]],
            solution: `One of these cells must be changed to avoid three ${grid[j][i] === CHAIR ? 'chairs' : 'sustainability symbols'} in a column`
          };
        }
      }
    }

    // Check for row/column balance
    for (let i = 0; i < 4; i++) {
      const rowChairs = grid[i].filter(cell => cell === CHAIR).length;
      const rowEco = grid[i].filter(cell => cell === ECO).length;
      if (rowChairs > 2 || rowEco > 2) {
        return {
          tip: `Check row ${i + 1}. Each row must have an equal number of chairs and sustainability symbols.`,
          highlight: [[i, 0], [i, 1], [i, 2], [i, 3]],
          solution: "This row needs balance between chairs and sustainability symbols"
        };
      }
    }

    // Generic hints for empty cells
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        if (grid[i][j] === EMPTY) {
          return {
            tip: "Look for patterns in the nearby cells.",
            highlight: [[i, j]],
            solution: "Try placing a piece here based on the surrounding symbols"
          };
        }
      }
    }

    return {
      tip: "The puzzle looks complete! Click 'Done' to check your solution.",
      highlight: [],
      solution: "Verify that all rules are followed"
    };
  };

  const validateGrid = (newGrid) => {
    const newErrors = [];

    // Check for adjacent pieces
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        if (newGrid[i][j] !== EMPTY) {
          // Check horizontal
          if (j < 2 && newGrid[i][j] === newGrid[i][j+1] && newGrid[i][j] === newGrid[i][j+2]) {
            newErrors.push({ row: i, col: j, type: 'adjacent' });
            newErrors.push({ row: i, col: j+1, type: 'adjacent' });
            newErrors.push({ row: i, col: j+2, type: 'adjacent' });
          }
          // Check vertical
          if (i < 2 && newGrid[i][j] === newGrid[i+1][j] && newGrid[i][j] === newGrid[i+2][j]) {
            newErrors.push({ row: i, col: j, type: 'adjacent' });
            newErrors.push({ row: i+1, col: j, type: 'adjacent' });
            newErrors.push({ row: i+2, col: j, type: 'adjacent' });
          }
        }
      }
    }

    setErrors(newErrors);
    return newErrors.length === 0;
  };

  const checkCompletion = (newGrid) => {
    const isFilled = newGrid.every(row => row.every(cell => cell !== EMPTY));
    if (!isFilled) return false;

    if (!validateGrid(newGrid)) return false;

    // Check row and column balance
    for (let i = 0; i < 4; i++) {
      const rowChairs = newGrid[i].filter(cell => cell === CHAIR).length;
      const rowEco = newGrid[i].filter(cell => cell === ECO).length;
      if (rowChairs !== rowEco) return false;

      const colChairs = newGrid.map(row => row[i]).filter(cell => cell === CHAIR).length;
      const colEco = newGrid.map(row => row[i]).filter(cell => cell === ECO).length;
      if (colChairs !== colEco) return false;
    }

    return true;
  };

  const handleDoneClick = () => {
    const isValid = checkCompletion(grid);
    
    // Check if grid is fully filled
    const isFilled = grid.every(row => row.every(cell => cell !== EMPTY));
    if (!isFilled) {
      setErrors([]);
      return showIncompleteMessage("Fill all cells before checking your solution!");
    }

    if (isValid) {
      setIsComplete(true);
      setIsActive(false);
    } else {
      // Get current hint to identify the issue
      const currentHint = generateHint();
      setHighlightedCells(currentHint.highlight);
      showIncompleteMessage("Nice try! But there are still some issues. Click 'Get Hint' for help.");
    }
  };

  const showIncompleteMessage = (message) => {
    setErrors([]); // Clear any existing errors
    setIncompleteMessage(message);
    // Clear message after 3 seconds
    setTimeout(() => setIncompleteMessage(null), 3000);
  };

  const getNextHint = () => {
    const hint = generateHint();
    setHintIndex(prev => prev + 1);
    setHighlightedCells(hint.highlight);
    return hint;
  };

  const cycleCell = (row, col) => {
    if (!isActive) setIsActive(true);
    setGrid(prevGrid => {
      const newGrid = prevGrid.map(r => [...r]);
      newGrid[row][col] = (newGrid[row][col] + 1) % 3;
      validateGrid(newGrid);
      return newGrid;
    });
  };

  const resetPuzzle = () => {
    setGrid([
      [EMPTY, EMPTY, EMPTY, EMPTY],
      [EMPTY, EMPTY, EMPTY, EMPTY],
      [EMPTY, EMPTY, EMPTY, EMPTY],
      [EMPTY, EMPTY, EMPTY, EMPTY]
    ]);
    setIsComplete(false);
    setErrors([]);
    setHintIndex(-1);
    setTime(0);
    setIsActive(false);
    setHighlightedCells([]);
    setIncompleteMessage(null);
  };

  const renderCell = (value, row, col) => {
    const hasError = errors.some(error => error.row === row && error.col === col);
    const isHighlighted = highlightedCells.some(([r, c]) => r === row && c === col);
    
    let content = '';
    switch(value) {
      case CHAIR:
        content = '🪑';
        break;
      case ECO:
        content = '🌿';
        break;
      default:
        content = '';
    }

    return (
      <div 
        className={`w-20 h-20 border 
          ${hasError ? 'border-red-500 bg-red-50' : 
           isHighlighted ? 'border-amber-500 bg-amber-50' : 'border-indigo-200'} 
          flex items-center justify-center text-3xl cursor-pointer 
          ${value === EMPTY ? 'hover:bg-indigo-50' : 'hover:bg-indigo-100'} 
          transition-colors duration-200`}
        onClick={() => cycleCell(row, col)}
      >
        {content}
      </div>
    );
  };

  const renderHorizontalConstraint = (constraint) => {
    if (!constraint) return null;
    return (
      <div className="w-6 flex items-center justify-center">
        {constraint === '=' ? (
          <div className="text-green-600 font-bold text-xl">=</div>
        ) : (
          <div className="text-red-600 font-bold text-xl">×</div>
        )}
      </div>
    );
  };

  const renderVerticalConstraint = (constraint) => {
    if (!constraint) return null;
    return (
      <div className="h-6 flex items-center justify-center">
        {constraint === '=' ? (
          <div className="text-green-600 font-bold text-xl">=</div>
        ) : (
          <div className="text-red-600 font-bold text-xl">×</div>
        )}
      </div>
    );
  };

  const renderExample = (title, content) => (
    <div className="bg-indigo-50 p-4 rounded-lg mb-4">
      <h3 className="font-semibold text-indigo-900 mb-2">{title}</h3>
      <div className="flex items-center gap-4">
        {content}
      </div>
    </div>
  );

  const renderMiniGrid = (pattern) => (
    <div className="grid grid-cols-3 gap-1">
      {pattern.map((row, i) => 
        row.map((cell, j) => (
          <div 
            key={`${i}-${j}`}
            className="w-8 h-8 flex items-center justify-center border border-indigo-200 bg-white"
          >
            {cell === 1 ? '🪑' : cell === 2 ? '🌿' : ''}
          </div>
        ))
      )}
    </div>
  );

  return (
    <div className="p-8 max-w-6xl mx-auto bg-gradient-to-b from-indigo-50 to-white">
      <div className="flex items-center justify-between mb-8">
        <h1 className="text-4xl font-bold text-indigo-900">Furniture & Nature: A KIAN Logic Game</h1>
        <img src="/api/placeholder/50/50" alt="KIAN Falcon Logo" className="h-12 w-12" />
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
        <div>
          <Alert className="mb-6 border-indigo-200 bg-white shadow-lg">
            <AlertTitle className="text-indigo-900 text-xl font-bold mb-4">How to Play</AlertTitle>
            <AlertDescription className="space-y-6">
              <ul className="list-disc pl-4 space-y-4 text-indigo-900">
                <li>Fill the grid with either chairs (🪑) or sustainability symbols (🌿)</li>
                {renderExample("Adjacent Rule", 
                  <>
                    {renderMiniGrid([
                      [1,1,1],
                    [0,0,0],
                      [0,0,0]
                    ])}
                    <span className="text-red-500">❌ Not Allowed</span>
                    {renderMiniGrid([
                      [1,1,2],
                      [0,0,0],
                      [0,0,0]
                    ])}
                    <span className="text-green-500">✓ Allowed</span>
                  </>
                )}
                <li>Cells connected by an = sign must have the same piece</li>
                {renderExample("Equal Sign Rule",
                  <>
                    <div className="flex items-center">
                      <div className="w-8 h-8 flex items-center justify-center border">🪑</div>
                      <div className="px-2">=</div>
                      <div className="w-8 h-8 flex items-center justify-center border">🪑</div>
                      <span className="ml-4 text-green-500">✓ Correct</span>
                    </div>
                  </>
                )}
                <li>Cells connected by an × sign must have different pieces</li>
                {renderExample("Different Sign Rule",
                  <>
                    <div className="flex items-center">
                      <div className="w-8 h-8 flex items-center justify-center border">🪑</div>
                      <div className="px-2">×</div>
                      <div className="w-8 h-8 flex items-center justify-center border">🌿</div>
                      <span className="ml-4 text-green-500">✓ Correct</span>
                    </div>
                  </>
                )}
              </ul>
            </AlertDescription>
          </Alert>

          {/* Game Controls */}
          <div className="flex gap-4 mb-6">
            <button
              onClick={getNextHint}
              className="flex items-center gap-2 px-4 py-2 bg-amber-500 text-white rounded hover:bg-amber-600 transition-colors shadow-md"
            >
              <Lightbulb className="h-4 w-4" />
              Get Hint
            </button>
            
            <button
              onClick={resetPuzzle}
              className="flex items-center gap-2 px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition-colors shadow-md"
            >
              <RefreshCcw className="h-4 w-4" />
              Reset
            </button>

            <button
              onClick={handleDoneClick}
              className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors shadow-md"
            >
              <Check className="h-4 w-4" />
              Done
            </button>

            <div className="flex items-center gap-2 px-4 py-2 bg-white rounded shadow-md">
              <Clock className="h-4 w-4 text-indigo-500" />
              {formatTime(time)}
            </div>
          </div>

          {/* Hint Display */}
          {hintIndex >= 0 && (
            <Alert className="mb-6 border-amber-200 bg-amber-50 shadow-md">
              <Lightbulb className="h-4 w-4 text-amber-800" />
              <AlertTitle className="text-amber-800 font-bold">Hint</AlertTitle>
              <AlertDescription className="space-y-2">
                <p className="text-amber-700">{generateHint().tip}</p>
                <p className="text-amber-900 font-semibold">{generateHint().solution}</p>
              </AlertDescription>
            </Alert>
          )}

          {/* Incomplete Message */}
          {incompleteMessage && (
            <Alert className="mb-6 border-amber-200 bg-amber-50 shadow-md">
              <AlertCircle className="h-4 w-4 text-amber-800" />
              <AlertDescription className="text-amber-800">
                {incompleteMessage}
              </AlertDescription>
            </Alert>
          )}

          {/* Completion Message */}
          {isComplete && (
            <Alert className="mb-6 border-green-200 bg-green-50 shadow-md">
              <Check className="h-4 w-4 text-green-800" />
              <AlertTitle className="text-green-800 text-xl font-bold">Congratulations!</AlertTitle>
              <AlertDescription className="space-y-4">
                <p className="text-green-700">
                  You've completed the puzzle in {formatTime(time)}!
                </p>
                <div className="bg-white p-4 rounded-lg">
                  <h3 className="font-semibold text-green-800 mb-2">Did You Know?</h3>
                  <p className="text-green-700">
                    {SUSTAINABILITY_FACTS[Math.floor(Math.random() * SUSTAINABILITY_FACTS.length)]}
                  </p>
                </div>
                <div className="flex items-center gap-2">
                  <ExternalLink className="h-4 w-4 text-indigo-500" />
                  <a 
                    href="https://www.kian.com/products" 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="text-indigo-500 hover:text-indigo-600"
                  >
                    Discover more sustainable furniture at KIAN
                  </a>
                </div>
              </AlertDescription>
            </Alert>
          )}
        </div>

        {/* Puzzle Grid */}
        <div className="bg-white p-8 rounded-lg shadow-xl border border-indigo-100">
          {grid.map((row, rowIndex) => (
            <div key={rowIndex}>
              {rowIndex > 0 && (
                <div className="flex">
                  {row.map((_, colIndex) => (
                    <div key={`vc-${colIndex}`} className="w-20 flex justify-center">
                      {renderVerticalConstraint(verticalConstraints[rowIndex-1][colIndex])}
                    </div>
                  ))}
                </div>
              )}
              <div className="flex">
                {row.map((cell, colIndex) => (
                  <React.Fragment key={colIndex}>
                    {renderCell(cell, rowIndex, colIndex)}
                    {colIndex < row.length - 1 && renderHorizontalConstraint(horizontalConstraints[rowIndex][colIndex])}
                  </React.Fragment>
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default KianPuzzle;
